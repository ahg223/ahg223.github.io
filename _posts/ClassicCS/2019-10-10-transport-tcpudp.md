---
title : OSI 7 - Transport Layer
excerpt : Detail - ARQ, Flow control, Congestion control

categories:
  - ClassicCS
tags:
  - ClassicCS
  - Network
---  

## 흐름제어 & 혼잡제어

### 흐름제어 (Flow Control)

수신측이 송신측보다 속도가 빠른 것은 아무런 문제가 되지 않지만, 송신측이 수신측보다 빠르다면 문제가 발생할 수 있다.
그렇기 때문에, 수신측이 더 느릴 경우 발생하는 문제점을 대처하기 위하여, 강제로 송신측의 데이터 전송을 조절하는 방법이다.


### Stop and Wait

![Stop-and-Wait](https://user-images.githubusercontent.com/44635266/66535053-3f666980-eb53-11e9-9c0e-b0fe5436bf2e.png)

매번 전송한 패킷에 대하여 확인응답을 받아야만 다음 패킷을 전송하는 방법이다.


### Sliding Window

![스크린샷 2019-10-08 오후 6 39 08](https://user-images.githubusercontent.com/44635266/66385173-05824f80-e9fb-11e9-805b-d0a05e20877c.png)

수신 측에서 윈도우 사이즈를 설정하여 이 크기만큼 세그먼트를 전송하는 기법이다.

이 윈도우 사이즈는 수신측의 여유 버퍼 공간을 반영하여 동적으로 결정한다.

### 혼잡제어(Congestion Control)

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 속도 차이로 인해 수신측은 데이터를 모두 처리 할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되어 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시킨다. 따라서 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라 한다.  

또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡(Congesetion)이라 하며 혼잡현상을 방지하거나 제거하는 기능을 혼잡제어라 한다. 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서의 전송 문제를 다룬다.

### AIMD (Additive Increase/Multiplicative Decrease)

처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송한다. 만일 패킷전송을 실패하거나 일정 시간을 넘으면 패킷을 보내는 속도를 절반으로 줄인다.

### Slow Start

AIMD처럼 1 패킷을 보내는 것부터 시작한 뒤, 패킷이 성공적으로 전송되면 윈도우 사이즈를 2배씩 증가시킨다.

이후, 혼잡현상이 발생하면 사이즈를 1로 떨어트리고, 이전 혼잡현상이 발생하였던 창 크기의 절반까지는 지수 함수 꼴로 창 크기를 증가시킨다. 그리고 이후부터는 다시 1씩 증가한다.  


### Fast Recovery

![스크린샷 2019-10-08 오후 6 38 40](https://user-images.githubusercontent.com/44635266/66385177-074c1300-e9fb-11e9-84f2-53c7d4cdd037.png)

빠른 회복 정책은 혼잡한 상태가 되면 Window size를 1로 줄이지 않고 반으로 줄인 뒤 선형 증가시키는 방법이다. 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 합 증가/곱 감소 방식으로 동작한다.

> Triple Duplicated ACK

![](https://user-images.githubusercontent.com/44635266/66916737-d604c000-f056-11e9-9271-996dabf15e21.png)

> Timeout

![](https://user-images.githubusercontent.com/44635266/66916738-d604c000-f056-11e9-88b7-fb9e7bb749f5.png)

### Fast Retransmit

수신측에서 유실 직전 패킷의 다음 순번을 ACK에 실어서 보낸다. 그러면 송신 측은 중복된 ACK를 받아 데이터의 유실을 알 수 있고, 유실된 패킷을 재전송 할 수 있게 된다. 송신측은 중복된 순번을 받으면 재전송을 하고, 유실이 일어났다는 것은 혼잡한 상황이라는 의미이므로 윈도우 사이즈를 감소시킨다.

