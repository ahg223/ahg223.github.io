---
title : Multi Processing  vs Multi Threading
excerpt : Detail - Context Switching, DeadLock 

categories:
  - ClassicCS
tags:
  - ClassicCS
  - OS
---  


## 멀티프로세스 vs 멀티 스레딩

### 멀티 프로세스

![](https://user-images.githubusercontent.com/44635266/67367760-1a411480-f5b1-11e9-917d-f06d76e25344.png)

여러 개의 프로세스가 서로 협력적으로 일을 처리하는 것이다. 즉, 여러 개의 프로세스가 작업을 병렬처리 하는 것이다.

멀티프로세스를 이용할 경우 한 프로세스가 고장나더라도 시스템이 정지하는 것이 아니라 단지 속도만 느려져 신뢰성도 보장할 수 있다.

하지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.

### 멀티 스레딩

![](https://user-images.githubusercontent.com/44635266/67368282-05b14c00-f5b2-11e9-9cc2-245551555d57.png)

하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다.
  
이 경우 각각의 스레드는 독립적인 작업을 수행해야 한다. 따라서 프로세스의 데이터 및 힙 영역을 공유하지만, 스레드 각자의 스택과 PC 레지스터 값을 갖고 있다. 다르게 표현하자면, 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 힙영역과 스태틱 영역을 공유하여 사용할 수 있다.

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 교환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다.

## 문맥교환(Context Switching)

![](https://user-images.githubusercontent.com/44635266/67374442-2383ae80-f5bc-11e9-8995-6b5b8f425e8b.png)

하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 CPU에 적재하는 작업을 말한다.  

인터럽트가 발생되었을 때 실행 중이던 프로세스가 작업을 멈춘 뒤 다시 실행될 때 이전 작업을 다시 수행하기 위해 이전 작업 내용과 프로세스의 정보들을 PCB에 저장해둔다. 즉, 한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록(PCB)에 기록되어 있다.

## 교착상태 (DeadLock)

![](https://user-images.githubusercontent.com/44635266/67373783-2c27b500-f5bb-11e9-9891-54106ad88165.png)

교착상태(Dead Lock)는 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상이다. 

### 교착상태의 조건

- 상호배제: 한 자원에 대한 여러 프로세스의 동시접근 불가
- 점유대기: 자원을 들고 다른 프로세스의 자원 반납 대기
- 비선점: 상대 자원 강제 취소 불가
- 순환대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있는 것

### 예방기법

- 예방: 사전에 시스템을 제어하는 방법으로 교착상태 발생의 네가지 조건 중에서 어느 하나를 제거한다
- 회피: 교착상태가 발생할 가능성을 배제하지 않고 적절히 피해나가는 방법으로, 주로 은행원 알고리즘(Banker's Algorithm)이 사용된다
- 회복: 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것을 의미한다

> 은행원 알고리즘(Banker's Algorithm)

은행원 알고리즘에서 운영체제는 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘이다.

