---
title: "가상머신부터 오케스트레이션 툴 까지"
excerpt: "OS, VM, cgroup, container, orchastration"

categories:
  - ModernCS
tags:
  - OS
  - Docker
  - Kubernetes
---
  
## 커널과 OS  
![image](https://user-images.githubusercontent.com/34998051/68454527-4230a900-023c-11ea-9149-0d8c100eee65.png)

대부분의 컴퓨터는 CPU, 보조기억장치(HDD, SSD), 무선 랜 카드 등의 하드웨어로 이루어져 있고, 하드웨어와 상호작용하는 소프트웨어가 내장된다. 그러한 소프트웨어 중 운영체제는 이러한 하드웨어와 소프트웨어를 운영하는 역할을 수행한다.  

그러한 운영체제 안에는 커널이 있는데, 이것은 소프트웨어와 하드웨어 간의 다리 역할을 수행한다. 어렵게 얘기하면 프로세스(소프트웨어의 최소 단위)의 스케쥴링, 디스크 혹은 메모리 읽고 쓰기 등을 해낸다. 위의 이미지와 같이 OS는 사용자가 사용자 공간을 사용함에 있어서 문제가 없도록 관리하고 운영해주는 역할을 수행한다.  



## Virtual Machine  
![image](https://user-images.githubusercontent.com/34998051/68454799-182bb680-023d-11ea-94b3-07ca683e8869.png)

이러한 운영체제는 당연히 많은 종류가 있고, 호환이 안되는 경우가 많다. 예를 들면 맥 OS와 윈도우가 그렇다.
이러한 경우들 때문에 하나의 컴퓨터에 여러 운영체제를 띄우려는 시도가 나오고, 그 중 하나가 바로 가상 머신이다.  

![image](https://user-images.githubusercontent.com/34998051/68455160-f979ef80-023d-11ea-9f65-f4bb759b0d74.png)

이미 운영체제(Host OS)가 존재하는 컴퓨터 위에 필요한 운영체제(Guest OS)를 올리고, 이 운영체제(Guest OS)에게 마치 하드웨어가 연결된 듯 속이는 소프트웨어(하이퍼바이저) 위에서 동작하게 만들어 속이는 것이다. 마치 위 그림과 같아지는데, 이때 host OS도 없이 하이퍼 바이저가 전부 관리하는 베어메탈 방식 등 여러 방식으로 가상 머신은 구성되고 운영된다.  



## cgroups  
control groups의 줄임말인 cgroups는 리눅스 OS의 커널 기능 중 유저 프로세스의 리소스를 관리하는 커널 기능이다. 이것은 여러 프로세스와 스레드(프로세스 내부의 작업 단위)를 그룹화(네임스페이스)하여 관리하는데, 그 수준이 매우 높았다. 간단히 말하자면, 네임스페이스 내부의 프로세스 들에게 해당 네임스페이스는 고유한 하나의 가상머신으로 보일 정도이다. 자세히 말하자면, 각각의 네임스페이스는 CPU 사용량 제한 및 메모리 배치 및 사용량 제어, 디바이스 입출력 량 제어, 네트워크 인터페이스 제어, 서로 다른 네임스페이스 간 PID 조회 불가능 등이 있다.  



##  Containers  
![image](https://user-images.githubusercontent.com/34998051/68455727-6641b980-023f-11ea-9852-69ca00deea4d.png)

cgroups는 LXC(linux container) 기술의 기반이 되었다. 다른 OS 구동을 위한 가상 머신에는 하이퍼바이저와 관련 host os와의 동기화 등 많은 작업이 필요했고, 꽤 부담이 되었다. 하지만 cgroups는 네임스페이스 분리를 통해 각각의 프로세스에게 네트워크 스페이스까지 격리된 가상 환경을 제공할 수 있게 해주었다. 이러한 리눅스 컨테이너 기술을 기반으로 많은 컨테이너 기술이 생겨났고, 그 중 산업 표준이 된 기술이 바로 Docker이다.  



## Docker  
![image](https://user-images.githubusercontent.com/34998051/68456124-54144b00-0240-11ea-800d-e9064bd186a2.png)

오늘날 컨테이너라 하면 대부분 Docker를 가르킬 정도로 유명한 오픈소스이다. cgroups, linux 커널과 윈도우 환경에서는 윈도우가 제공하는 네임 스페이스 기술을 기반으로 발전하였다. 다른 컨테이너와 공통점은, 하나의 OS가 이미지로 저장된 뒤 추후에 가상 환경을 구축하기 위하여 구동되는데, 이 OS 안에는 파일 시스템, 바이너리, 커널 등을 전부 포함해야 하지만 이 이미지는 오직 파일 시스템과 바이너리만 포함하여 가볍다는 점이다.   

![image](https://user-images.githubusercontent.com/34998051/68456475-30053980-0241-11ea-90f2-2b9a8c0c4355.png)


기존 컨테이너와 차이점을 짚어보자면, 도커의 유니온 파일 시스템이 있다. 도커의 이미지는 여러 이미지의 레이어로 구성되어 수정이 되는 만큼만 업데이트하면 된다. 예를 들어, 4gb 크기의 이미지 중 3mb만큼 수정이 더해졌다면 이를 다시 이미지로 만들 때 4.003gb를 다시 이미지로 만드는 것이 아니라 3mb만큼 만 업데이트가 되어 속도가 빠르다. 또 다른 예시를 들어보자면, 하나의 컴퓨터 위에 a b d로 구성된 이미지와 a b c로 구성된 이미지를 돌려야한다고 가정하자. 이때, 해당 컴퓨터에는 a b c d가 한개씩 저장된 뒤 위 사진처럼 a b를 공유한다. 그 후 각 이미지를 구동시키고 cgroup과 네임스페이스를 생성해 각각의 가상 환경은 완전히 독립된 머신과 같이 운영된다.     

이러한 컨테이너는 경량성 그 이상의 장점이 있다. docker만 설치되어 있다면, OS가 ubuntu, MacOS, Windows, CentOS 등 상관없이 컨테이너 내부는 설정한 OS가 되어 동작한다는 점이다. 또한 표준화된 작업 또는 연산의 단위가 되었다. 예를 들어, DB를 sharding하려 한다면 DB 하나를 이미지로 만들어 여러 개의 컨테이너로 작동시키면 된다. 각각의 DB에게 cpu, ram, 스레드 수 등 여러 세세한 리소스를 할당하고 조정하던 전과는 다르게 "컨테이너 몇개를 띄우냐"는 훨씬 쉬운 추상화를 제공한다.  



## Orchestarion  
그렇다면 몇 백개의 가상 머신에 몇 만개의 컨테이너를 배포하고 싶다면 도커로 충분할까? 컨테이너 간 네트워킹과 volume 개념 등 docker는 이러한 것들을 훨씬 쉽게 만들어 주었지만 부족한 부분이 많다. 가상 머신 간의 네트워킹, 갑작스런 컨테이너 크러쉬 혹은 다운에 대한 대응, 업그레이드나 롤백 같은 시시각각 변하는 시스템 성질 처리 자동화에 있어 docker 하나만으로는 아직 역부족이다.  

이러한 것을 돕기 위하여 새로 생겨난 툴이 바로 orchestration이다. 컨테이너에 대한 로드 밸런싱 부터 새로운 컨테이너로 모든 리소스를 적용, 클라이언트가 모르게 자동화 된 복구를 실행하며 특별한 이미지 구성 없이 암호와 같이 중요한 정보를 따로 저장하고 관리할 수 있다.   
  
    
    
[참고 자료](https://goofcode.github.io/container-101)
