<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-11-08T12:56:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">선생보단 학생</title><subtitle>가르치는 것 보다 배우는 게 재밌더라</subtitle><author><name>ahg223</name></author><entry><title type="html">Super vs Cloud vs Grid</title><link href="http://localhost:4000/moderncs/super-cloud/" rel="alternate" type="text/html" title="Super vs Cloud vs Grid" /><published>2019-11-05T00:00:00+09:00</published><updated>2019-11-06T02:00:00+09:00</updated><id>http://localhost:4000/moderncs/super-cloud</id><content type="html" xml:base="http://localhost:4000/moderncs/super-cloud/">&lt;p&gt;슈퍼 컴퓨터란?  &lt;br /&gt;
전용 OS를 사용하여 모든 컴퓨터 리소스를 하나로 묶어 작업을 처리한다. 내부를 보면 여러 컴퓨터 리소스가 병렬로 연결되어 있지만, 인피니 밴드 등으로 각각을 연결해 네트워크를 통한 병렬처리와는 속도의 차이가 많이 난다.&lt;/p&gt;

&lt;p&gt;그리드 컴퓨팅이란?&lt;br /&gt;
분산 컴퓨팅 모델. 하나의 작업을 각각의 OS가 설치된 여러 컴퓨팅 자원이 네트워크로 통신하며 작업을 처리하는 것으로, 각각의 컴퓨팅 자원에 대해서는 각자가 소유한다.&lt;/p&gt;

&lt;p&gt;클라우드 컴퓨팅이란?&lt;br /&gt;
중앙 집중식 모델. 데이터 센터가 한 곳에 존재하고, 사용자들은 이 컴퓨팅 자원을 대여하여 필요한 OS를 설치한 뒤 필요한 작업을 수행한다. 처음 개념이 등장할 때만 하더라도 한명이 컴퓨터 리소스를 관리한다는 것 외에는 큰 차이가 없었지만, 인피니밴드로 각각의 컴퓨팅 자원을 묶으며 기능을 향상시키는 등 하드웨어 구조는 오히려 슈퍼 컴퓨터와 유사해져가고 있다.&lt;/p&gt;

&lt;p&gt;글 제목: Super vs Cloud vs Grid
수정 시간: 2019-11-05 17:00:00 +0000&lt;/p&gt;</content><author><name>ahg223</name></author><category term="Cloud" /><category term="GridComputer" /><category term="SuperComputer" /><summary type="html">difference between them</summary></entry><entry><title type="html">VM vs Container</title><link href="http://localhost:4000/moderncs/vm-container/" rel="alternate" type="text/html" title="VM vs Container" /><published>2019-11-05T00:00:00+09:00</published><updated>2019-11-06T02:00:00+09:00</updated><id>http://localhost:4000/moderncs/vm-container</id><content type="html" xml:base="http://localhost:4000/moderncs/vm-container/">&lt;p&gt;VM - 가상머신이란?  &lt;br /&gt;
가상의 하드웨어를 만들어 낸 뒤 OS를 설치하여 연동하므로, 하드웨어 복사본 및 운영체제 복사본을 가진다. 많은 RAM과 CPU 싸이클을 소모한다.&lt;/p&gt;

&lt;p&gt;컨테이너란?&lt;br /&gt;
OS와 보조 프로그램, 라이브러리, 적은 시스템 리소스만을 필요로 한다. VM에 비해 2~3배 많은 애플리케이션을 하나의 서버에서 처리할 수 있게 된다. 이러한 가벼운 특성 덕분에 개발, 테스트, 배포가 에자일하게 가능해진다.&lt;/p&gt;

&lt;p&gt;VM과 컨테이너의 장단점&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;컨테이너는 보안 문제가 존재한다. 컨테이너의 특성 때문에 /sys 아래의 디바이스 및 SELinux 등 많은 커널 서브 시스템을 컨테이너에서 다루게 되는데, 이 말인 즉슨 이론상으로 superuser 권한을 가진 컨테이너 유저는 OS를 크랙할 수 있다.&lt;/li&gt;
  &lt;li&gt;많은 컨테이너화 된 애플리케이션을 많은 사람들이 배포하는데, 각각의 이미지에 대한 보장이 없어 에러 코드가 같이 다운될 수 있다.&lt;/li&gt;
  &lt;li&gt;컨테이너는 하나의 애플리케이션을 실행하는 것에 초점이 맞춰져 있다. 마이크로 서비스를 원하지 않거나 더 많은 기능을 포함하고 싶다면 가상 머신을 사용하는 것이 옳다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;글 제목: VM vs Container
수정 시간: 2019-11-05 17:00:00 +0000&lt;/p&gt;</content><author><name>ahg223</name></author><category term="VirtualMachine" /><category term="Container" /><summary type="html">difference between them</summary></entry><entry><title type="html">docker vs k8s</title><link href="http://localhost:4000/moderncs/docker-k8s/" rel="alternate" type="text/html" title="docker vs k8s" /><published>2019-11-05T00:00:00+09:00</published><updated>2019-11-06T02:00:00+09:00</updated><id>http://localhost:4000/moderncs/docker-k8s</id><content type="html" xml:base="http://localhost:4000/moderncs/docker-k8s/">&lt;p&gt;컨테이너와 오케스트레이션이란?&lt;br /&gt;
컨테이너는 하드웨어의 복제본을 필요하지 않게 함으로써 가상머신과 같이 특정 환경을 몇 초만에 구성하고 정지시켜준다.&lt;br /&gt;
컨테이너가 위와 같은 장점이 있고, 소규모 컨테이너를 실험해보고 싶다면 도커 만으로도 충분하다. 하지만 정식 서비스를 운영하기 위해 데이터베이스, 웹 프론트엔드, 미들웨어, 백엔드 등 여러 컨테이너로 하나의 애플리케이션을 구성하는 경우는 어떠할까? 하나의 앱을 구성하는 것도 쉽지 않은데 이 모든 것의 상태와 통신, 그리고 에러 및 로그를 실시간으로 보는 것은 불가능하다. 그렇기에 나온 컨테이너 관리 툴이 바로 오케스트레이션이다.&lt;/p&gt;

&lt;p&gt;docker란?&lt;br /&gt;
컨테이너를 사용자 친화적이고 개발자 친화적인 환경으로 구성한 오픈소스이다. 도커 덕분에 컨테이너 이미지를 생성할 때 고려해야 할 점이 비할 수 없이 간편해졌고, 도커 허브와 같은 플랫폼을 통해 이미지 관리 및 공유가 편리해졌다.&lt;/p&gt;

&lt;p&gt;위와 같은 성격 덕분에 도커는 엄청난 확장성, 격리성, 이식성을 갖게 되었다.&lt;br /&gt;
확장성 - 수요가 짐작이 가지 않는 환경에서 관리자는 그 수요에 따라 컨테이너화 된 앱의 인스턴스를 시시각각 변화시켜야 한다. 도커는 이를 가능하게 한다.&lt;br /&gt;
격리성 - 같은 앱이라도 다른 버전을 띄워 특정 앱들과만 통신해야할 때가 있다. 예를들면 MySQL ver5.5이 필요한 A, B 앱이 있고 MySQL ver5.7이 필요한 C, D 앱이 있다면 이 6가지 앱은 격리될 필요가 있다. 혹은 기반 시스템을 깨끗하게 유지하기 위해서도 필요할 때가 많다.&lt;br /&gt;
이식성 - 같은 앱을 여러 환경에서 구동하고, 환경마다 달라지는 구성을 복제할 때 유용하다.&lt;/p&gt;

&lt;p&gt;kubernetes란?&lt;br /&gt;
구글 클라우드 서비스에서 사용 중인 오케스트레이션 툴이다. 컨테이너가 크루즈 선의 승객이라면, 도커는 최고의 승객 안내 요원이고 쿠버네티스는 그러한 크루즈 선의 선장이라고 할 수 있다. 개발자가 각 컨테이너의 네트워킹 및 스토리지 사용 방식 등의 세부 정보만 정의해준다면 쿠버네티스가 런타임에서 나머지 부분을 전부 처리해준다.&lt;/p&gt;

&lt;p&gt;글 제목: docker vs k8s
수정 시간: 2019-11-05 17:00:00 +0000&lt;/p&gt;</content><author><name>ahg223</name></author><category term="Cloud" /><category term="Docker" /><category term="Kubernetes" /><summary type="html">difference between them</summary></entry><entry><title type="html">Cache</title><link href="http://localhost:4000/classiccs/cash/" rel="alternate" type="text/html" title="Cache" /><published>2019-11-01T00:00:00+09:00</published><updated>2019-11-01T00:00:00+09:00</updated><id>http://localhost:4000/classiccs/cash</id><content type="html" xml:base="http://localhost:4000/classiccs/cash/">&lt;h2 id=&quot;caches&quot;&gt;Caches&lt;/h2&gt;

&lt;p&gt;캐시는 CPU 칩 안에 들어가는 작고 빠른 메모리다. (그리고 비싸다.) 프로세서가 매번 메인 메모리에 접근해 데이터를 받아오면 시간이 오래 걸리기 때문에 캐시에 자주 사용하는 데이터를 담아두고, 해당 데이터가 필요할 때 프로세서가 메인 메모리 대신 캐시에 접근하도록해 처리 속도를 높인다.&lt;/p&gt;

&lt;p&gt;CPU 칩에는 여러 개의 캐시가 들어가며, 각각의 캐시는 각자의 목적과 역할을 가지고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------------+------+------+     +---------------+     +--------+
|             |  I$  |      | &amp;lt;-- |               | &amp;lt;-- |        |
+  Processor  +------+  L2  |     |  Main Memory  |     |  Disk  |
|             |  D$  |      | --&amp;gt; |               | --&amp;gt; |        |
+-------------+------+------+     +---------------+     +--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;L1 Cache: 프로세서와 가장 가까운 캐시. 속도를 위해 I$와 D$로 나뉜다.
    &lt;ul&gt;
      &lt;li&gt;Instruction Cache (I$): 메모리의 TEXT 영역 데이터를 다루는 캐시.&lt;/li&gt;
      &lt;li&gt;Data Cache (D$): TEXT 영역을 제외한 모든 데이터를 다루는 캐시.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;L2 Cache: 용량이 큰 캐시. 크기를 위해 L1 캐시처럼 나누지 않는다.&lt;/li&gt;
  &lt;li&gt;L3 Cache: 멀티 코어 시스템에서 여러 코어가 공유하는 캐시.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67973039-26813d80-fc53-11e9-9057-24dc8f9c58a5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;principle-of-locality&quot;&gt;Principle of Locality&lt;/h3&gt;

&lt;p&gt;캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다. 이러한 역할을 수행하기 위해서는 CPU 가 어떤 데이터를 원할 것인가를 어느 정도 예측할 수 있어야 한다. 캐시의 성능은 작은 용량의 캐시 메모리에 CPU 가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우되기 때문이다.&lt;/p&gt;

&lt;p&gt;이 때 적중율(Hit rate)을 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용한다. 지역성의 전제조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access 하지 않는다는 특성을 기본으로 한다. 즉, Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67973037-25501080-fc53-11e9-8119-538e43233ba1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 데이터 지역성은 대표적으로 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.&lt;/li&gt;
  &lt;li&gt;공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cache-metrics&quot;&gt;Cache Metrics&lt;/h3&gt;

&lt;p&gt;캐시의 성능을 측정할 때는 히트 레이턴시(Hit latency)와 미스 레이턴시(Miss latency)가 중요한 요인으로 꼽힌다.&lt;/p&gt;

&lt;p&gt;CPU에서 요청한 데이터가 캐시에 존재하는 경우를 캐시 히트(Hit)라고 한다. 히트 레이턴시는 히트가 발생해 캐싱된 데이터를 가져올 때 소요되는 시간을 의미한다. 반면 요청한 데이터가 캐시에 존재하지 않는 경우를 캐시 미스(Miss)라고 하며, 미스 레이턴시는 미스가 발생해 상위 캐시에서 데이터를 가져오거나(L1 캐시에 데이터가 없어서 L2 캐시에서 데이터를 찾는 경우) 메모리에서 데이터를 가져올 때 소요되는 시간을 말한다.&lt;/p&gt;

&lt;p&gt;평균 접근 시간(Average access time)은 다음과 같이 구한다:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67973044-284b0100-fc53-11e9-8d13-808cb3d4b015.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캐시의 성능을 높이기 위해서는 캐시의 크기를 줄여 히트 레이턴시를 줄이거나, 캐시의 크기를 늘려 미스 비율을 줄이거나, 더 빠른 캐시를 이용해 레이턴시를 줄이는 방법이 있다&lt;/p&gt;

&lt;h3 id=&quot;caching-line&quot;&gt;Caching line&lt;/h3&gt;

&lt;p&gt;CPU가 메모리 주소를 사용하여 메모리로 데이터를 받을려고 한다. 하지만 CPU가 쓰는 주소는 가상 메모리 주소로 메모리 입장에서는 외계어다. 따라서 중간에 메모리 관리 장치(MMU)가 가운데에서 번역을 하여 메모리가 알아 먹을 수 있는 물리 주소로 변환을 해준다. 그리고 캐시에 해당 주소에 대한 데이터가 있는지 확인을 하는데 캐시에 데이터를 저장하는 방식에 따라 물리주소를 다르게 해석을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67989204-66591c80-fc75-11e9-92c1-eef98600a1e0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇기 때문에 캐시에 데이터를 저장할 때 특정 자료구조를 사용하여 묶음으로 저장하게 되는데 이를 캐싱 라인 이라고 한다. 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소는 흩어져 있다. 따라서 캐시에 저장하는 데이터에는 데이터의 메모리 주소 등을 기록해 둔 태그를 달아놓을 필요가 있다. 이러한 태그들의 묶음을 캐싱 라인이라고 하고 메모리로부터 가져올 때도 캐싱 라인을 기준으로 가져온다. 종류로는 대표적으로 세 가지 방식이 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;direct-mapping&quot;&gt;Direct Mapping&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67989158-475a8a80-fc75-11e9-8854-9cdcef83ac08.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 메인 메모리에서 캐시로 데이터를 저장할 때 참조의 지역성 때문에 한번 퍼낼 때 인접한 곳까지 한꺼번에 캐시 메모리에 저장하고 이 때 단위를 블록(Block)라고 한다. 그리고 캐쉬는 메인 메모리의 몇번째 블록인지를 알려주는 태그(Tag)도 함께 저장한다.&lt;/p&gt;

&lt;p&gt;메모리 주소 중에 가장뒷부분(붉은색)은 블럭의 크기를 의미한다. 지금 블럭의 크기가 4이므로 뒤의 두자리를 사용하여 블럭의 크기를 표현하였다. 그리고 이 영역은 블럭에 몇 번째에 원하는 데이터가 있는지 보여주는 지표가 되어 준다. 만일 위의 예에서 붉은 영역이 01이라면 블록의 두 번째 내용을 CPU에서 요청한 것이다.&lt;/p&gt;

&lt;p&gt;같은 라인에 위치하는 데이터는 파란색 색칠한 영역에 의하여 구별이 가능하다.. 예를 들면 메모리의 첫번째 요소 00000과 다섯번째 주소 00100은 캐시내에 같은 위치에 자리잡고 있어서 구별이 필요로 한데, 앞의 세자리 000과 001로 구별을 할 수 있다.&lt;/p&gt;

&lt;p&gt;이와 같은 요소의 활용은 캐시 메모리에 저장된 데이터 중 내가 원하는 것이 있는지 없는지 확인이 가능하다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;캐시의 태그와 주소상의 태그가 동일한지 확인한 후 같으면 붉은 영역을 통해 데이터를 읽는다.&lt;/li&gt;
  &lt;li&gt;만일 태그가 다르다면 메모리에서 데이터를 가지고 온다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;직접 매핑은 위의 사진처럼 캐시에 저장된 데이터들은 메인 메모리에서와 동일한 배열을 가지도록 매핑하는 방법을 말한다. 이와 같은 방식을 사용하기 때문에 매우 단순하고 탐색이 쉽다는 장점이 있다. 하지만 적중률(Hit ratio)가 낮다는 단점이 있다. 반복문을 사용할 건데 같은 라인의 00000을 불렀다가 그다음엔 00100을 부른다면 캐시에 빈번하게 변경이 발생할수 있기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;associative-mapping&quot;&gt;Associative Mapping&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67989160-488bb780-fc75-11e9-975c-2c19e43fb80a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연관 매핑은 직접 매핑의 단점을 보완하기 위해 등장하였다. 캐시에 저장된 데이터들은 메인 메모리의 순서와는 아무런 관련이 없다. 이와 같은 방식을 사용하기 때문에 캐시를 전부 뒤져서 태그가 같은 데이터가 있는지 확인해야한다. 따라서 병렬 검사를 위해 복잡한 회로를 가지고 있는 단점이 있지만 적중률이 높다는 장점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;set-associative-mapping&quot;&gt;Set Associative Mapping&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67989163-49244e00-fc75-11e9-99fa-4b09e5f3276f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직접 매핑의 단순한 회로와 연관 매핑의 적중률 두 개의 장점만을 취하기 위해서 만들어진 방식이다.
각각의 라인들은 하나의 에 속해 있다. 세트 번호를 통해 영역을 탐색하므로 연관 매핑의 병렬 탐색을 줄일 수 있다그리고 모든 라인에 연관 매핑처럼 무작위로 위치하여 직접매핑의 단점도 보완하였다. 세트 안의 라인 수에 따라 n-way연관 매핑이라고 한다.(위 그림은 2-way 연관 매핑)&lt;/p&gt;</content><author><name>ahg223</name></author><category term="ClassicCS" /><summary type="html">Need retouch</summary></entry><entry><title type="html">Little Endian vs Big Endian</title><link href="http://localhost:4000/classiccs/endian/" rel="alternate" type="text/html" title="Little Endian vs Big Endian" /><published>2019-10-30T00:00:00+09:00</published><updated>2019-10-30T00:00:00+09:00</updated><id>http://localhost:4000/classiccs/endian</id><content type="html" xml:base="http://localhost:4000/classiccs/endian/">&lt;h2 id=&quot;엔디언endianness&quot;&gt;엔디언(Endianness)&lt;/h2&gt;

&lt;p&gt;엔디언은 컴퓨터 메모리와 같이 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법 특히 바이트 순서라한다.&lt;/p&gt;

&lt;p&gt;우선 리틀 엔디안은 주로 인텔 게열의 CPU에서 이용하는 바이트 오더링 방식으로, 가장 낮은 바이트부터 정렬하는 방식이고,&lt;/p&gt;

&lt;p&gt;빅 엔디안은 주로 AMD계열의 CPU에서 이용하는 방식으로, 가장 높은 바이트부터 정렬하며, 사람이 읽기 좋은 정렬 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/66379803-2645a780-e9f1-11e9-9ad0-7bbbeca2a0d1.png&quot; alt=&quot;스크린샷 2019-10-08 오후 5 23 48&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;장단점&quot;&gt;장단점&lt;/h2&gt;

&lt;p&gt;빅엔디언은 소프트웨어 디버깅을 편하게 해줍니다. 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리 값을 보기 편합니다.&lt;/p&gt;

&lt;p&gt;예를들어, 위 데이터는 0A 0B 0C 0D로 표현됩니다.&lt;/p&gt;

&lt;p&gt;리틀 엔디언은 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요가 없습니다. 보통 변수의 첫 바이트를 그 변수의 주소로 삼기 때문에 이런 성질이 장점이 됩니다.&lt;/p&gt;

&lt;p&gt;또한, 가산기 덧셈을 하는 과정에서 LSB로 시작하여 자리 올림을 계산해야 하므로, 첫 번째 바이트가 LSB인 리틀엔디언에서는 가산기 설계가 더 단순해집니다.&lt;/p&gt;

&lt;p&gt;단, 네트워크를 통해 전송될 때는 엔디안 방식의 차이에 주의해야 합니다. 네트워크 데이터 통신에서는 빅엔디안을 따르도록해야합니다.&lt;/p&gt;

&lt;p&gt;참고로 아래는 리틀/빅 엔디안을 사용하는 시스템입니다.&lt;/p&gt;

&lt;h3 id=&quot;리틀-엔디안&quot;&gt;리틀 엔디안&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Linux on x86, x64, Alpha and Itanium&lt;/li&gt;
  &lt;li&gt;Mac OS X on x86, x64&lt;/li&gt;
  &lt;li&gt;OpenVMS on VAX, Alpha and Itanium&lt;/li&gt;
  &lt;li&gt;Solaris on x86, x64, PowerPC&lt;/li&gt;
  &lt;li&gt;Tru64 UNIX on Alpha&lt;/li&gt;
  &lt;li&gt;Windows on x86, x64 and Itanium&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;빅-엔디안&quot;&gt;빅 엔디안&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;AIX on POWER&lt;/li&gt;
  &lt;li&gt;AmigaOS on PowerPC and 680x0&lt;/li&gt;
  &lt;li&gt;HP-UX on Itanium and PA-RISC&lt;/li&gt;
  &lt;li&gt;Linux on MIPS, SPARC, PA-RISC, POWER, PowerPC, 680x0, ESA/390, and z/Architecture&lt;/li&gt;
  &lt;li&gt;Mac OS on PowerPC and 680x0
Mac OS X on PowerPC&lt;/li&gt;
  &lt;li&gt;MVS and DOS/VSE on ESA/390, and z/VSE and z/OS on z/Architecture&lt;/li&gt;
  &lt;li&gt;Solaris on SPARC&lt;/li&gt;
&lt;/ul&gt;</content><author><name>ahg223</name></author><category term="ClassicCS" /><summary type="html">Need retouch</summary></entry><entry><title type="html">Wget</title><link href="http://localhost:4000/wget/" rel="alternate" type="text/html" title="Wget" /><published>2019-10-29T00:00:00+09:00</published><updated>2019-10-29T00:00:00+09:00</updated><id>http://localhost:4000/wget</id><content type="html" xml:base="http://localhost:4000/wget/">&lt;p&gt;title: “wget - how stable”
excerpt: “Development”&lt;/p&gt;

&lt;p&gt;categories:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Development
tags:&lt;/li&gt;
  &lt;li&gt;Development
last_modified_at: 2019-08-23T22:00:00
—&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;글 제목: Wget
수정 시간:&lt;/p&gt;</content><author><name>ahg223</name></author><summary type="html">title: “wget - how stable” excerpt: “Development”</summary></entry><entry><title type="html">Npz</title><link href="http://localhost:4000/npz/" rel="alternate" type="text/html" title="Npz" /><published>2019-10-28T00:00:00+09:00</published><updated>2019-10-28T00:00:00+09:00</updated><id>http://localhost:4000/npz</id><content type="html" xml:base="http://localhost:4000/npz/">&lt;p&gt;title: “npz - how to unzip npz file from binary”
excerpt: “Development”&lt;/p&gt;

&lt;p&gt;categories:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Development
tags:&lt;/li&gt;
  &lt;li&gt;Development
last_modified_at: 2019-08-23T22:00:00
—
CASE : npz of lot of npz &amp;amp;&amp;amp; download by torrent&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;frombuffer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;saved as binaryIO&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;reading binary of npz file&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3-1. np.load process&lt;/p&gt;

&lt;p&gt;3-2. check about magic number and crc&lt;/p&gt;

&lt;p&gt;3-3.&lt;/p&gt;

&lt;p&gt;글 제목: Npz
수정 시간:&lt;/p&gt;</content><author><name>ahg223</name></author><summary type="html">title: “npz - how to unzip npz file from binary” excerpt: “Development”</summary></entry><entry><title type="html">메모리 관리</title><link href="http://localhost:4000/classiccs/memory-manage/" rel="alternate" type="text/html" title="메모리 관리" /><published>2019-10-27T00:00:00+09:00</published><updated>2019-10-27T00:00:00+09:00</updated><id>http://localhost:4000/classiccs/memory-manage</id><content type="html" xml:base="http://localhost:4000/classiccs/memory-manage/">&lt;h3 id=&quot;메모리-관리-배경&quot;&gt;메모리 관리 배경&lt;/h3&gt;

&lt;p&gt;각각의 프로세스 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.&lt;/p&gt;

&lt;p&gt;Swapping : 메모리의 관리를 위해 사용되는 기법. 표준 Swapping 방식으로는 round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 과정을 &lt;strong&gt;swap&lt;/strong&gt; (&lt;strong&gt;스왑시킨다&lt;/strong&gt;) 이라 한다. 주 기억장치(RAM)으로 불러오는 과정을 &lt;strong&gt;swap-in&lt;/strong&gt;, 보조 기억장치로 내보내는 과정을 &lt;strong&gt;swap-out&lt;/strong&gt; 이라 한다. swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;단편화-fragmentation&quot;&gt;단편화 (Fragmentation)&lt;/h3&gt;

&lt;p&gt;프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 단편화 이다. 단편화는 2 가지 종류로 나뉜다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67660206-92d51600-f9a1-11e9-9d3c-e39aebb1f7b5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생한다고 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이 가 존재하고, 이 현상을 내부 단편화라 칭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67660211-949ed980-f9a1-11e9-90f1-8e0fc728703b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;paging페이징&quot;&gt;Paging(페이징)&lt;/h3&gt;

&lt;p&gt;하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다.
외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)&lt;/p&gt;

&lt;p&gt;페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단점 : 내부 단편화 문제의 비중이 늘어나게 된다. 예를들어 페이지 크기가 1,024B 이고 프로세스 A 가 3,172B 의 메모리를 요구한다면 3 개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B 가 남기때문에 총 4 개의 페이지 프레임이 필요한 것이다. 결론적으로 4 번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;segmentation세그먼테이션&quot;&gt;Segmentation(세그먼테이션)&lt;/h3&gt;

&lt;p&gt;페이징 기법에서는 가상메모리를 같은 크기의 단위로 분할했으나&lt;/p&gt;

&lt;p&gt;세크멘테이션 기법에서는 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고 메모리를 할당하며 주소 변환을 하게 됩니다.  (각각의 세그먼트들은 연속적인 공간에 저장되어있습니다)&lt;/p&gt;

&lt;p&gt;세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상메모리 관리 기법입니다.&lt;/p&gt;

&lt;p&gt;페이징기법과 마찬가지로 mapping을 위해 세그먼트 테이블을 필요로 합니다.&lt;/p&gt;

&lt;p&gt;이 기법은 하나의 세그먼트 단위로 통제가 가능한 장점이 있습니다. 즉, 내부단편화가 발생하지 않습니다. 그러나 서로 다른 크기의 세그먼트들에 대해 필요시에 메모리에 올리고 필요없을 경우 내리는 작업을 반복하다보면 외부 단편화가 생기는 문제점이 있습니다.&lt;/p&gt;</content><author><name>ahg223</name></author><category term="ClassicCS" /><summary type="html">Need retouch</summary></entry><entry><title type="html">Token vs Coin</title><link href="http://localhost:4000/moderncs/token-coin/" rel="alternate" type="text/html" title="Token vs Coin" /><published>2019-10-27T00:00:00+09:00</published><updated>2019-10-27T00:00:00+09:00</updated><id>http://localhost:4000/moderncs/token-coin</id><content type="html" xml:base="http://localhost:4000/moderncs/token-coin/">&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/44635266/67632220-2f38e300-f8e4-11e9-9fe4-d76ed0b3c583.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;token-과-coin의-차이&quot;&gt;Token 과 Coin의 차이&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;토큰&lt;/strong&gt;과 &lt;strong&gt;코인&lt;/strong&gt;의 결정적인 차이를 한마디로 정의하자면 바로 &lt;strong&gt;메인넷&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;메인넷은 독립적인 블록체인 생태계를 구성하는 것을 말하고 이러한 메인넷을 가지고 있는 암호화폐를 코인 이라 부르며 암호화폐 거래가 이루어질 수 있도록 지갑 및 기타 클라이언트 프로그램이 개발되어 자체적인 생태계를 지니고 있습니다.&lt;/p&gt;

&lt;p&gt;반면에, 토큰은 기존 플렛폼에서 파생되어 만들어진 암호화폐를 토큰이라 부릅니다. 현재 이더리움을 베이스로 하고 있는 토큰들이 많습니다.&lt;/p&gt;

&lt;p&gt;오늘날 전 세계 토큰의 표준인 &lt;strong&gt;ERC-20(Ethereum Request for Comment)&lt;/strong&gt; 토큰의 경우 이더리움 네트워크 블록체인을 기반으로 하는 하는 DAPP(Decentralized Application, 탈중앙화 응용 프로그램)에서 사용할 수 있는 토큰을 의미한다. 넓은 의미에서 화폐 뿐만 아니라 자산의 기능도 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Example&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코인 : 독립된 블록체인 네트워크(메인넷)를 소유한 경우 코인으로 부른다. 예를 들면, 비트코인(BTC), 이더리움(ETH), 퀀텀(QTUM), 스팀(STEEM), 넴(NEM) 등을 들 수 있다.&lt;/p&gt;

&lt;p&gt;토큰 : 독립된 블록체인 네트워크를 소유하지 않은 경우 토큰으로 부른다. 예를 들면, 이오스(EOS), 트론(TRX) 등을 들 수 있다.&lt;/p&gt;</content><author><name>ahg223</name></author><category term="ModernCS" /><category term="Blockchain" /><summary type="html">Introduction</summary></entry><entry><title type="html">Peer</title><link href="http://localhost:4000/moderncs/peer/" rel="alternate" type="text/html" title="Peer" /><published>2019-10-27T00:00:00+09:00</published><updated>2019-10-27T00:00:00+09:00</updated><id>http://localhost:4000/moderncs/peer</id><content type="html" xml:base="http://localhost:4000/moderncs/peer/">&lt;h2 id=&quot;anchor-peer&quot;&gt;Anchor Peer&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Anchor Peer&lt;/code&gt; 는 조직 간의 피어들에 대한 정보 교환의 대리인으로 사용된다. 이로써 서로에 대한 위치를 알게 되어 Peer 하나에서 체인코드를 시작하면 모두에 적용될 수 있게 되며 MSP에 대한 공유도 가능해진다.적어도 하나의 앵키피어가 채널 설정시 정의되야하며, 채널에 참여하는 피어들은 제네시스 블록안에 기록된 앵커피어에 대한 정보를 공유하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;ledaing-peer&quot;&gt;Ledaing Peer&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Leading Peer&lt;/code&gt; 는 조직 내에서 피어들간의 오더러로 부터 받은 블록을 공유하기 위한 대표 피어이다. 이 피어가 맛이가면 조직내의 피어들끼리 리더선출을 통해서 새로운 리더를 선출하고 오더러에 알려서 정상적으로 작동하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;endorsing-peer&quot;&gt;Endorsing Peer&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트에 수행될 트랜잭션을 시뮬레이션해보고 그 결과를 클라이언트 어플리케이션에 리턴해주는 피어입니다. 트랜잭션을 검증하는 역할을 하는 거죠. 즉, 체인코드 시뮬레이션을 통해 트랜잭션이 적절한지 판단하는 역할을한다.&lt;/p&gt;

&lt;h2 id=&quot;committing-peer&quot;&gt;Committing Peer&lt;/h2&gt;

&lt;p&gt;오더링까지 되어서 전달된 트랜잭션 블럭을 검증하고, 검증이 완료되면 자기가 갖고 있는 원장에 해당 블럭을 추가하고 관리합니다. 모든 피어는 기본적으로 committing peer입니다.&lt;/p&gt;</content><author><name>ahg223</name></author><category term="ModernCS" /><category term="Blockchain" /><summary type="html">Introduction</summary></entry></feed>